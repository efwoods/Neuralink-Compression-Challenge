#!/usr/bin/python3

import pickle
import sys
import os

sys.path.insert(0, os.path.join(os.path.abspath(os.path.dirname(__file__)), ".."))
from utility import signal_process


def convert_bytes_to_bitstring(data_to_decode, endZeroPadding):
    """This function converts bytes into a string of bits.

    Args:
        data_to_decode (str): This is the string of bytes that will be
                              converted into bits.
        endZeroPadding (int): This is the number of zeroes that were
                              padded into the final byte. They will be
                              removed so the resultant bit string can be
                              properly decompressed.

    Returns:
        bitString (str): This is the string of bits that will need to be
                         parsed into hexadecimal pairs that represent
                         the bytes of the decompressed wave file.
    """
    bitString = ""
    for byteIndex in range(0, len(data_to_decode)):
        bitStringByte = format(data_to_decode[byteIndex], "b")
        bitStringByte = "0" * (8 - len(bitStringByte)) + bitStringByte
        bitString += bitStringByte
    bitString = bitString[: len(bitString) - endZeroPadding]
    return bitString


def find_key_by_value_in_node_mapping_dictionary(
    val_str_to_find, nodeMappingDictionary
):
    """This function allows the searching of the nodeMappingDictionary
    for a key given a value.

    Args:
        val_str_to_find (str): This is expected to be a string of bits.
        nodeMappingDictionary (dict): This is the dictionary that maps
                                      hexadecimal values as keys in the
                                      dictionary to uniquely identifying
                                      strings of bits as values.

    Returns:
        key_mapped_to_value (list): This function returns the
                                    hexadecimal pair found as a key in
                                    the nodeMappingDictionary given a
                                    string of bit values. If the given
                                    string of bits is not found in the
                                    dictionary, the return value is
                                    'None'.
    """
    try:
        key_mapped_to_value = list(nodeMappingDictionary.keys())[
            list(nodeMappingDictionary.values()).index(val_str_to_find)
        ]
    except ValueError:
        return None
    return key_mapped_to_value


def huffman_decoding(huffman_encoded_data: str):
    """This is the algorithm that decodes a huffman encoded string of bytes.

    Args:
        huffman_encoded_data (str): This is the string of bytes to be
                                    decoded.

    Returns:
        decoded_wav_bytes (bytes): This is the byte string that has been
                                   decoded by the huffman decoding
                                   algorithm.
    """

    nodeMappingDictionary = pickle.loads(huffman_encoded_data)
    indices_byte_size = huffman_encoded_data[len(huffman_encoded_data) - 1]
    indices_pickle = huffman_encoded_data[
        len(huffman_encoded_data)
        - 1
        - indices_byte_size : len(huffman_encoded_data)
        - 1
    ]
    indices_array = pickle.loads(indices_pickle)
    data_to_decode = huffman_encoded_data[indices_array[1] : indices_array[2]]
    bitString = convert_bytes_to_bitstring(data_to_decode, indices_array[-1])

    # Parse the string of bits into hexadecimal values.
    hex_value_array = []
    bitLength = 0
    while len(bitString) > 0:
        key = find_key_by_value_in_node_mapping_dictionary(
            bitString[:bitLength], nodeMappingDictionary
        )
        if key is not None:
            hex_value_array.append(key)
            bitString = bitString[bitLength:]
            bitLength = 0
        else:
            bitLength += 1
    hex_wav_str = ""
    hex_wav_str = hex_wav_str.join(hex_value_array)
    decoded_wav_bytes = bytes.fromhex(hex_wav_str)
    return decoded_wav_bytes


def read_huffman_encoded_file(
    compressed_file_path: str = None, decompressed_file_path: str = None
):
    """The main driving method that will decode a huffman encoded file.

    Args:
        compressed_file_path (str, optional): The path of the compressed
                                              file to decompress.
                                              Defaults to None.

    """

    if compressed_file_path == None:
        compressed_file_path = sys.argv[1]

    # Retrieve the encoded file for decoding and parse the file.
    with open(compressed_file_path, "rb+") as file:
        huffman_encoded_data = file.read()
    return huffman_encoded_data


def write_decoded_wav(decoded_wav, decompressed_file_path: str = None):
    """_summary_

    Args:
        decoded_wav (array): This is the array of amplitudes to be
                             written to a file.
        decompressed_file_path (str, optional): The path of the output
                                                decompressed file.
                                                Defaults to None.
    """

    if decompressed_file_path == None:
        decompressed_file_path = sys.argv[2]

    with open(decompressed_file_path, "wb+") as fp:
        fp.write(decoded_wav.tobytes())
        fp.close()


if __name__ == "__main__":
    huffman_encoded_data = read_huffman_encoded_file()
    decoded_wav_bytes = huffman_decoding(huffman_encoded_data)
    encoded_data = signal_process.convert_byte_string_to_encoded_data(decoded_wav_bytes)
    sample_rate, amplitude_array = signal_process.decode_data(encoded_data)
    write_decoded_wav(decoded_wav=amplitude_array)
