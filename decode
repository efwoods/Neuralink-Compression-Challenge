#!/usr/bin/python3

import sys
from scipy.io import wavfile
import numpy as np
from signal_processing_utilities import process_signal
import time
import os


def decode_rle(
    index_array: list,
    rle_locations_in_index_array=[],
    use_rle_locations=False,
    UNSIGNED_INTEGER_CUTOFF_VALUE=65530,
):
    """This will expand the index array where the values have been
       compressed by run-length-encoding. If use_rle_locations is set to
       'False', then the index_array will be presumed to have a format of
       ['value', 'frequency', 'value', etc...]. A separate
       implementation is defined to parse this format. If
       use_rle_locations is set to 'True', then the
       rle_locations_in_index_array is non-optional and must be used as
       an input.

    Args:
        index_array (list): This is a list of values which contain
                            either signular values or run-length-encoded
                            values followed by the frequency of the
                            run-length-encoded value.
        rle_locations_in_index_array (list, optional): This is a list of
                              locations in the index_array where the
                              locations have been run-length-encoded.
                              The subsequent values of these locations
                              are frequencies of the run-length-encoded
                              values.

    Returns:
        reconstructed_array (list): This is the list of the original
                                    values before run-length-encoding
                                    was applied.
    """

    index = 0
    rle_index = 0
    rle_location = 0
    reconstructed_array = []

    if use_rle_locations:
        try:
            if rle_locations_in_index_array:
                # rle_locations_in_index_array exists
                pass
        except:
            error_string = (
                "rle_locations_in_index_array must be "
                + "declared when 'use_rle_locations' is set to 'True'."
            )
            raise NameError(error_string)
        rle_location_split_array = identify_index_split(rle_locations_in_index_array)
        current_rle_location_split_array_index = 0

        while rle_index < len(rle_locations_in_index_array):
            try:
                if (
                    rle_index
                    >= rle_location_split_array[current_rle_location_split_array_index]
                ):
                    current_rle_location_split_array_index += 1
            except:
                # This is an Index Location Error: the
                # rle_location_split_array contains indices that are
                # innermost boundaries within the
                # larger rle_locations_in_index_array array. That is to say,
                # the rle_locations_in_index_array
                # array will surpass the ultimate location in the
                # rle_location_split_array. The index of the
                # rle_location_split_array will not need to be incremented as
                # the index is being used as a scalar to scale the value of the
                # UNSIGNED_INTEGER_CUTOFF_VALUE to properly calculate the
                # rle_location in the index_array.
                pass

            rle_location = rle_locations_in_index_array[rle_index] + (
                current_rle_location_split_array_index * UNSIGNED_INTEGER_CUTOFF_VALUE
            )

            reconstructed_array.extend(index_array[index:(rle_location)])

            rle_index_of_value = rle_location
            rle_index_of_frequency = rle_location + 1

            expanded_rle_value = [
                index_array[rle_index_of_value]
                for frequency in range(index_array[rle_index_of_frequency])
            ]

            reconstructed_array.extend(expanded_rle_value)
            index = rle_index_of_value + 2
            rle_index += 1

        reconstructed_array.extend(index_array[index:])
        return reconstructed_array
    else:
        while index < len(index_array):
            reconstructed_array.extend(
                [index_array[index] for value in range(index_array[index + 1])]
            )
            index += 2
        return reconstructed_array


# RLE for bit compression
def rle_bit_compression(byte_string: bytes, compress=True, rle_locations=None):
    """This function will compress the byte string using
    run-length-encoding. It will create a rle_locations byte string to
    differentiate between frequency and value locations. When compress
    is set to true, rle_locations is non-optional. The return value
    established when compress is set to true is the expected input.
    This is labeled "rle_locations_compressed_byte_string". If
    "compress" is set to "False", the return values are the byte
    string object of the original byte_string input and the
    rle_locations as a list of integers. The rle_locations can be
    safely ignored.

    Args:
        byte_string (bytes): This is a bytes object of 0 and 1 values.
        compress (bool, optional): This is a flag to indicate if mode
                                   is to compress or decompress.
                                   Defaults to True.
        rle_locations (_type_, optional): These are the rle_locations
                                          that are used when
                                          decompressing. If "compress"
                                          is equal to "True", then this
                                          can safely be set to "None".
                                          Otherwise, this is a mandatory
                                          input. Defaults to None.

    Returns:
        rle_compressed_bytes (bytes): This is a byte string object of
                                       the compressed byte_string.
        rle_locations_compressed_byte_string (bytes): This is a
                                                      compressed byte
                                                      string object of
                                                      the rle_locations.
    """
    if compress:
        byte_string_str = str(byte_string).lstrip("b'").rstrip("'")
        # Convert byte string to string of bits

        initial_index = 0
        second_index = 1
        frequency = 0
        rle_compression = []
        rle_locations = []

        # RLE compessing the byte_string_str
        while second_index < len(byte_string_str):
            if byte_string_str[initial_index] == byte_string_str[second_index]:
                rle_compression.append(str(byte_string_str[initial_index]))
                frequency += 1
                while byte_string_str[initial_index] == byte_string_str[second_index]:
                    second_index += 1
                    frequency += 1
                    if second_index >= len(byte_string_str):
                        break
                rle_compression.append(str(frequency))
            else:
                rle_compression.append(byte_string_str[initial_index])
                rle_compression.append("x")
            frequency = 0
            initial_index = second_index
            second_index += 1
        # Accounting for the case of the frequency
        #   byte_string_str[second_index] not being accounted for if it
        #   is a unique value.
        # If non-unique, this will be handled by the frequency in the
        #   second while loop. Otherwise the second_index will be
        #   larger than the length of the byte_string_str, and the
        #   frequency of the individual value must be declared.

        if byte_string_str[-2] != byte_string_str[-1]:
            if rle_compression[-1] != "x":  # Redundancy to prevent error
                rle_compression.append("x")

        # verify rle_compression has captured all values:
        total = 0
        for index in range(0, len(rle_compression), 2):
            if rle_compression[index + 1] == "x":
                total += 1
            else:
                total = total + int(rle_compression[index + 1])

        # RLE locations array run-length-encoded compression:
        # -1 signifies the start of a run-length-encoding.
        # Otherwise the value is written individually.

        # Establishing RLE Locations
        for index in range(0, len(rle_compression)):
            rle_locations.append(len(rle_compression[index]))

        # Compression of RLE Locations
        initial_index = 0
        second_index = 1
        frequency = 0
        rle_locations_compressed = []
        while second_index < len(rle_locations):
            if rle_locations[initial_index] == rle_locations[second_index]:
                rle_locations_compressed.append(-1)
                rle_locations_compressed.append(rle_locations[initial_index])
                frequency += 1
                while rle_locations[initial_index] == rle_locations[second_index]:
                    second_index += 1
                    frequency += 1
                    if second_index >= len(rle_locations):
                        break
                rle_locations_compressed.append(frequency)
            else:
                rle_locations_compressed.append(rle_locations[initial_index])
            frequency = 0
            initial_index = second_index
            second_index += 1
        if rle_locations[-2] != rle_locations[-1]:
            rle_locations_compressed.append(rle_locations[-1])

        # RLE Locations Compressed to Byte String:
        rle_locations_compressed_byte_string_l = [
            rle_locations_compressed[index].to_bytes(2, "big", signed=True)
            for index in range(len(rle_locations_compressed))
        ]
        rle_locations_compressed_byte_string = b""
        for byte in rle_locations_compressed_byte_string_l:
            rle_locations_compressed_byte_string += byte

        rle_compression_join = "".join(rle_compression)
        rle_compressed_bytes = bytes(rle_compression_join, encoding="utf-8")

        return rle_compressed_bytes, rle_locations_compressed_byte_string
    else:
        rle_compressed_bytes = byte_string
        rle_locations_compressed_byte_string = rle_locations
        # RLE Locations Compressed Byte String Expansion:
        # int.from_bytes(, signed=True)
        rle_locations_compressed_byte_string_l = [
            rle_locations_compressed_byte_string[index : index + 2]
            for index in range(len(rle_locations_compressed_byte_string))
        ]

        rle_locations_compressed = []
        for index in range(0, len(rle_locations_compressed_byte_string_l), 2):
            rle_locations_compressed.append(
                int.from_bytes(
                    rle_locations_compressed_byte_string_l[index], signed=True
                )
            )

        # Expansion of RLE Locations Compressed:
        rle_locations = []
        index = 0
        # rle_locations appears to have locations and rle_compression
        # This is causing an error.
        while index < len(rle_locations_compressed):
            if rle_locations_compressed[index] != -1:
                rle_locations.append(rle_locations_compressed[index])
                index += 1
            else:
                index += 1
                rle_expanded_value_l = []
                rle_value = rle_locations_compressed[index]
                rle_value_frequency = rle_locations_compressed[index + 1]
                rle_expanded_value_l = [
                    rle_value for index in range(rle_value_frequency)
                ]
                rle_locations.extend(rle_expanded_value_l)
                index += 2

        # Original Byte Expansion
        rle_compressed_bytes_index = 0
        rle_location_index = 0
        rle_compressed_str_l = []

        while rle_location_index < len(rle_locations):
            rle_compressed_str = (
                str(
                    rle_compressed_bytes[
                        rle_compressed_bytes_index : rle_compressed_bytes_index
                        + rle_locations[rle_location_index]
                    ],
                )
                .lstrip("b'")
                .rstrip("'")
            )
            rle_compressed_str_l.append(rle_compressed_str)

            rle_compressed_bytes_index += rle_locations[rle_location_index]
            rle_location_index += 1

        # Expand rle_compressed_int_l to a string
        byte_string_str = ""
        index = 0
        while index < len(rle_compressed_str_l):
            byte_string_str_subset_value = rle_compressed_str_l[index]
            byte_string_str_subset_value_frequency = rle_compressed_str_l[index + 1]
            if byte_string_str_subset_value_frequency != "x":
                byte_string_str_subset_l = [
                    byte_string_str_subset_value
                    for value in range(int(byte_string_str_subset_value_frequency))
                ]
                byte_string_str_subset_str = "".join(byte_string_str_subset_l)
                byte_string_str += byte_string_str_subset_str
                index += 2
            else:
                byte_string_str += byte_string_str_subset_value
                index += 2

        # Convert String type to original byte string
        byte_string = bytes(byte_string_str, encoding="utf-8")
        return byte_string, rle_locations


def convert_bytes_to_bit_string(data_to_decode, end_zero_padding):
    """This function converts bytes into a string of bits.

    Args:
        data_to_decode (str): This is the string of bytes that will be
                              converted into bits.
        end_zero_padding (int): This is the number of zeroes that were
                              padded into the final byte. They will be
                              removed so the resultant bit string can be
                              properly decompressed.

    Returns:
        bit_string (str): This is the string of bits that will need to
                          be parsed into hexadecimal pairs that
                          represent the bytes of the decompressed wave
                          file.
    """
    bit_string = ""
    for byteIndex in range(0, len(data_to_decode)):
        bit_string_byte = format(data_to_decode[byteIndex], "b")
        bit_string_byte = "0" * (8 - len(bit_string_byte)) + bit_string_byte
        bit_string += bit_string_byte
    bit_string = bit_string[: len(bit_string) - end_zero_padding]
    return bit_string


def find_key_by_value_in_node_mapping_dictionary(
    val_str_to_find, node_mapping_dictionary
):
    """This function allows the searching of the node_mapping_dictionary
    for a key given a value.

    Args:
        val_str_to_find (str): This is expected to be a string of bits.
        node_mapping_dictionary (dict): This is the dictionary that maps
                                      hexadecimal values as keys in the
                                      dictionary to uniquely identifying
                                      strings of bits as values.

    Returns:
        key_mapped_to_value (list): This function returns the
                                    hexadecimal pair found as a key in
                                    the node_mapping_dictionary given a
                                    string of bit values. If the given
                                    string of bits is not found in the
                                    dictionary, the return value is
                                    'None'.
    """
    try:
        key_mapped_to_value = list(node_mapping_dictionary.keys())[
            list(node_mapping_dictionary.values()).index(val_str_to_find)
        ]
    except ValueError:
        return None
    return key_mapped_to_value


def huffman_decoding(huffman_encoded_data: str):
    """This is the algorithm that decodes a huffman encoded string of bytes.

    Args:
        huffman_encoded_data (str): This is the string of bytes to be
                                    decoded.

    Returns:
        decoded_wav_bytes (bytes): This is the byte string that has been
                                   decoded by the huffman decoding
                                   algorithm.
    """

    # Capturing the indices of the huffman_encoded_data
    """ The last two bytes of the huffman_encoded_data are the length of
        the indices within the huffman_encoded_data.
    """
    indices_length = int.from_bytes(huffman_encoded_data[-2:])

    reconstructed_indices_bytes = huffman_encoded_data[-(indices_length) - 2 : -2]

    reconstructed_indices = [
        int.from_bytes(reconstructed_indices_bytes[index : index + 4])
        for index in range(0, len(reconstructed_indices_bytes), 4)
    ]

    # Capturing the End Zero Padding:
    end_zero_padding = reconstructed_indices[-1]

    # Node Mapping Dictionary Keys:
    reconstructed_node_mapping_dictionary_keys_byte_string = huffman_encoded_data[
        0 : reconstructed_indices[0]
    ]

    reconstructed_node_mapping_dictionary_keys_string = str(
        reconstructed_node_mapping_dictionary_keys_byte_string, encoding="utf-8"
    )
    reconstructed_node_mapping_dictionary_keys_l = [
        reconstructed_node_mapping_dictionary_keys_string[index : index + 2]
        for index in range(0, len(reconstructed_node_mapping_dictionary_keys_string), 2)
    ]

    # Node Mapping Dictionary Values Expansion:

    # Node Mapping Dictionary Values (rle_compressed):
    rle_compressed_bytes = huffman_encoded_data[
        reconstructed_indices[0] : reconstructed_indices[1]
    ]

    # Node Mapping Dictionary Values RLE Compressed Indices (rle_compressed):
    rle_locations_compressed_byte_string = huffman_encoded_data[
        reconstructed_indices[1] : reconstructed_indices[2]
    ]

    node_mapping_dictionary_values_byte_string, _ = rle_bit_compression(
        byte_string=rle_compressed_bytes,
        rle_locations=rle_locations_compressed_byte_string,
        compress=False,
    )

    # Node Mapping Dictionary Values Indices:
    node_mapping_dict_values_indices_length_compressed_byte_string = (
        huffman_encoded_data[reconstructed_indices[2] : reconstructed_indices[3]]
    )
    reconstructed_node_mapping_dict_values_indices_length_l = decode_rle(
        node_mapping_dict_values_indices_length_compressed_byte_string
    )

    # Capturing the bit_string:
    bit_string_bytes = huffman_encoded_data[
        reconstructed_indices[3] : reconstructed_indices[4]
    ]

    bit_string = convert_bytes_to_bit_string(bit_string_bytes, end_zero_padding)

    # Parsing the Node Mapping Dictionary
    byte_string_index = 0

    reconstructed_node_mapping_dictionary = {}

    for index in range(0, len(reconstructed_node_mapping_dictionary_keys_l)):
        # Key
        key_str = reconstructed_node_mapping_dictionary_keys_l[index]

        # Value original dictionary is bytes
        value_byte = node_mapping_dictionary_values_byte_string[
            byte_string_index : byte_string_index
            + reconstructed_node_mapping_dict_values_indices_length_l[index]
        ]
        value_str = str(value_byte).lstrip("b'").rstrip("'")
        reconstructed_node_mapping_dictionary[key_str] = value_str
        byte_string_index += reconstructed_node_mapping_dict_values_indices_length_l[
            index
        ]

    reconstructed_node_mapping_dictionary_sorted = dict(
        sorted(
            reconstructed_node_mapping_dictionary.items(),
            key=lambda items: len(items[1]),
        )
    )

    # Parse the string of bits into hexadecimal values.
    hex_value_array = []
    bitLength = 0
    while len(bit_string) > 0:
        key = find_key_by_value_in_node_mapping_dictionary(
            bit_string[:bitLength], reconstructed_node_mapping_dictionary_sorted
        )
        if key is not None:
            hex_value_array.append(key)
            bit_string = bit_string[bitLength:]
            bitLength = 0
        else:
            bitLength += 1

    hex_wav_str = ""
    hex_wav_str = hex_wav_str.join(hex_value_array)
    decoded_wav_bytes = bytes.fromhex(hex_wav_str)
    return decoded_wav_bytes


def read_encoded_file(compressed_file_path: str = None):
    """The main driving method that will decode a huffman encoded file.

    Args:
        compressed_file_path (str, optional): The path of the compressed
                                              file to decompress.
                                              Defaults to None.

    """

    if compressed_file_path == None:
        compressed_file_path = sys.argv[1]

    # Retrieve the encoded file for decoding and parse the file.
    with open(compressed_file_path, "rb+") as file:
        huffman_encoded_data = file.read()
    return huffman_encoded_data


def write_decoded_wav(sample_rate, decoded_wav, decompressed_file_path: str = None):
    """This function writes the decoded bytes to a wav file.

    Args:
        sample_rate (int): This is the rate the audio was sampled.
        decoded_wav (array): This is the array of amplitudes to be
                             written to a file.
        decompressed_file_path (str, optional): The path of the output
                                                decompressed file.
                                                Defaults to None.
    """

    if decompressed_file_path == None:
        decompressed_file_path = sys.argv[2]

    wavfile.write(filename=decompressed_file_path, rate=sample_rate, data=decoded_wav)


def process_huffman_encoded_file():
    """This is the driver function that processes a huffman encoded file
    format."""

    huffman_encoded_data = read_encoded_file()
    decoded_wav_bytes = huffman_decoding(huffman_encoded_data)

    # The sample rate of the data is known in advance.
    write_decoded_wav(
        sample_rate=19531,
        decoded_wav=np.frombuffer(decoded_wav_bytes, dtype=np.int16),
    )


def process_spike_detection_huffman_encoded_data():
    """This is the driver function that processes a huffman encoded file
    format that has been encoded in such a way as to only detect neural
    spikes."""

    huffman_encoded_data = read_encoded_file()
    decoded_wav_bytes = huffman_decoding(huffman_encoded_data)
    encoded_data = process_signal.convert_byte_string_to_encoded_data(decoded_wav_bytes)
    sample_rate, amplitude_array = process_signal.decode_data(encoded_data)
    write_decoded_wav(
        sample_rate=sample_rate,
        decoded_wav=amplitude_array,
    )


def decompress(byte_string: bytes):
    """This function accepts a compressed byte string compressed
    using "brainwire" compression from the encode module. It then
    decompresses this data into the original array of amplitudes except
    only detected neural spike information is present. There are
    zero-valued amplitudes at all other locations of the original
    waveform. The decompressed representation returned as the
    sample_rate and corresponding amplitude_array.

    Args:
        file (str): This is the string of the compressed file path. The
                    expected encoding file type is ".brainwire"
    """
    decoded_wav_bytes = huffman_decoding(byte_string)
    encoded_data = process_signal.convert_byte_string_to_encoded_data(
        encoded_data_byte_string=decoded_wav_bytes
    )
    sample_rate, amplitude_array = process_signal.decode_data(encoded_data)
    return sample_rate, amplitude_array


def main():
    """This is the main driver logic of the decode function."""
    # process_huffman_encoded_file()
    process_spike_detection_huffman_encoded_data()


if __name__ == "__main__":
    main()
