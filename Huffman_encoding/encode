#!/usr/bin/python3

# Read a wave file '0ab237b7-fb12-4687-afed-8d1e2070d621.wav'
# convert the wave file to bytes
# convert the byte array to hex
# begin Huffman encoding

from scipy.io.wavfile import read, write
import heapq
import pickle

class Node:
    def __init__(self, freq, data, left = None, right = None):
        self.freq = freq
        self.data = data
        self.left = left
        self.right = right
        self.code = ''
    
    def __lt__(self, nxt):
        return self.freq < nxt.freq
    
def createNodeMappingDictionary(node, val = '', nodeMappingDict = {}):
    newVal = val + str(node.code)
    # if node is not an edge node, traverse
    if(node.left):
        createNodeMappingDictionary(node.left, newVal, nodeMappingDict)
    if(node.right):
        createNodeMappingDictionary(node.right, newVal, nodeMappingDict)
    if(not node.left and not node.right):
        nodeMappingDict[node.data] = newVal
        # print(f"{node.data} -> {newVal}")
    return nodeMappingDict

def read_file():
    # Read the text into bytes:
    with open("data/0ab237b7-fb12-4687-afed-8d1e2070d621.wav", "rb") as wavfile:
        input_wav = wavfile.read()
    wavfile.close()
    return input_wav

def determine_hex_freq(input_wav):
    input_wav_hex = input_wav.hex()
    hex_freq_dictionary = {}
    for digit_position in range(0, len(input_wav.hex()), 2):
        current_hex_pair = input_wav_hex[digit_position] + input_wav_hex[digit_position + 1]
        try:
            hex_freq_dictionary[current_hex_pair] += 1
        except KeyError:
            hex_freq_dictionary[current_hex_pair] = 1
    sorted_hex_freq_dictionary = dict(sorted(hex_freq_dictionary.items(), key = lambda x:x[1]))
    return sorted_hex_freq_dictionary

    # parse the file from hex to a bit string
def convertHexToBit(input_wav, nodeMappingDict):
    hex_input_wav = input_wav.hex()
    bitString = ''
    for index in range(0, len(hex_input_wav), 2):
        hex_pair = hex_input_wav[index] + hex_input_wav[index + 1]
        bitString += nodeMappingDict[hex_pair]
    endZeroPadding = '0'*(8-(len(bitString) % 8))
    bitString += endZeroPadding
    return bitString, len(endZeroPadding)
    # add dictionary "nodeMappingDict" to the outputfile

# Purpose: This function writes the encoded outputfile. 
# Inputs: 
#   nodeMappingDict: This is the dictionary which maps each hexadecimal representation of the bytes of the input wave file to a string of bits whose length is depended on frequency of the hexadecimal pair
#   bitString: This is the string of bits that is interpreted from the original input wave file and parsed using the nodeMappingDict
#   endZeroPadding: This is the number of zeroes that are padded to the end of the bitString to create a full set of bytes to be written to the output data file.
# Returns: No return. Outputs a file.dat which is the compressed version of the original wav file.
# Notes: The encoding is the pickled nodeMappingDictionary, the encoded data as bytes, the indices of the start and end of each data portion as mentioned here, and the size in bytes of the indices.
# The last index of the indices array contains the value of the number of zeros that the encoded data is padded with. 
# This is because the last index would be the length of the encoded data file, but this information can be interpreted otherwise.
# To decode this file, read the last byte of the file, use this information to calculate the position of the pickled indices array, 
# deserialize this section of the file, then use the indices and the knowledge of the order of the storage of this information to deserialize and read the bytes. 
# Finally, convert the encoded bytes into the original format using the node mapping dictionary to write the hex representation of the encoded informaiton.
def write_file(nodeMappingDict, bitString, endZeroPadding):
    with open('file.dat', 'wb+') as file:
        num_bytes = 1
        byteorder = 'big'
        indices = []
        indices.append(file.tell())
        file.write(pickle.dumps(nodeMappingDict))
        indices.append(file.tell())
        for index in range(0, len(bitString), 8):
            byte_to_write = bitString[index:index+7]
            int_of_byte_to_write = int(byte_to_write, 2)
            file.write(int_of_byte_to_write.to_bytes(num_bytes, byteorder=byteorder))
        indices.append(file.tell())
        indices.append(endZeroPadding)
        bytes_indices = file.write(pickle.dumps(indices))
        file.write(bytes_indices.to_bytes(1, byteorder=byteorder))

if __name__ == '__main__':
    # print('Huffman Encoding')
    input_wav = read_file()
    sorted_hex_freq_dict = determine_hex_freq(input_wav)
    hex_freq_values = list(sorted_hex_freq_dict.values())
    hex_freq_keys = list(sorted_hex_freq_dict.keys())

    # Create a list of nodes
    nodes = []
    for item in range(len(hex_freq_keys)):
        heapq.heappush(nodes, Node(hex_freq_values[item], hex_freq_keys[item]))

    # Build the node tree
    while len(nodes) > 1:
        left = heapq.heappop(nodes)
        right = heapq.heappop(nodes) 
        left.code = 0
        right.code = 1
        newNode = Node(left.freq+right.freq, left.data+right.data, left=left, right=right)
        heapq.heappush(nodes, newNode)
    nodeMappingDict = createNodeMappingDictionary(nodes[0], val = '', nodeMappingDict = {})

    # The hexadecimal representation of the bytes of the input wave file is converted to a string of bits to write
    bitString, endZeroPadding = convertHexToBit(input_wav, nodeMappingDict)

    # The bits are written by using single bytes of integers
    write_file(nodeMappingDict, bitString, endZeroPadding)
    
    # Decoding 