#!/usr/bin/python3

# Read a wave file '0ab237b7-fb12-4687-afed-8d1e2070d621.wav'
# convert the wave file to bytes
# convert the byte array to hex
# begin Huffman encoding

from scipy.io.wavfile import read, write
import heapq

class Node:
    def __init__(self, freq, data, left = None, right = None):
        self.freq = freq
        self.data = data
        self.left = left
        self.right = right
        self.code = ''
    
    def __lt__(self, nxt):
        return self.freq < nxt.freq
    
def createNodeMappingDictionary(node, val = '', nodeMappingDict = {}):
    newVal = val + str(node.code)
    # if node is not an edge node, traverse
    if(node.left):
        createNodeMappingDictionary(node.left, newVal, nodeMappingDict)
    if(node.right):
        createNodeMappingDictionary(node.right, newVal, nodeMappingDict)
    if(not node.left and not node.right):
        nodeMappingDict[node.data] = newVal
        # print(f"{node.data} -> {newVal}")
    return nodeMappingDict

def read_file():
    # Read the text into bytes:
    with open("data/0ab237b7-fb12-4687-afed-8d1e2070d621.wav", "rb") as wavfile:
        input_wav = wavfile.read()
    wavfile.close()
    return input_wav


def determine_hex_freq(input_wav):
    input_wav_hex = input_wav.hex()
    hex_freq_dictionary = {}
    for digit_position in range(0, len(input_wav.hex()), 2):
        current_hex_pair = input_wav_hex[digit_position] + input_wav_hex[digit_position + 1]
        try:
            hex_freq_dictionary[current_hex_pair] += 1
        except KeyError:
            hex_freq_dictionary[current_hex_pair] = 1
    sorted_hex_freq_dictionary = dict(sorted(hex_freq_dictionary.items(), key = lambda x:x[1]))
    return sorted_hex_freq_dictionary

# def write_file():
#     # Write bits to file
#     with open('output.txt', "wb") as outfile:
        
if __name__ == '__main__':
    print('Huffman Encoding')
    input_wav = read_file()
    sorted_hex_freq_dict = determine_hex_freq(input_wav)
    hex_freq_values = list(sorted_hex_freq_dict.values())
    hex_freq_keys = list(sorted_hex_freq_dict.keys())
    
    # Create a list of nodes
    nodes = []
    for item in range(len(hex_freq_keys)):
        heapq.heappush(nodes, Node(hex_freq_values[item], hex_freq_keys[item]))
    
    # Build the node tree
    while len(nodes) > 1:
        left = heapq.heappop(nodes)
        right = heapq.heappop(nodes)
        left.code = 0
        right.code = 1
        newNode = Node(left.freq+right.freq, left.data+right.data, left=left, right=right)
        heapq.heappush(nodes, newNode)
    nodeMappingDict = createNodeMappingDictionary(nodes[0], val = '', nodeMappingDict = {})    
    
    # parse the file from hex to a bit string
def convertHexToBit(input_wav, nodeMappingDict):
    hex_input_wav = input_wav.hex()
    bitString = ''
    for index in range(0, len(hex_input_wav), 2):
        hex_pair = hex_input_wav[index] + hex_input_wav[index + 1]
        bitString += nodeMappingDict[hex_pair]
    endZeroPadding = '0'*(8-(len(bitString) % 8))
    bitString += endZeroPadding
    return bitString, len(endZeroPadding)
    

    # add dictionary "nodeMappingDict" to the outputfile

# Purpose: This function writes the encoded outputfile. 
# Inputs: 
# Returns:
# Notes: The encoding the length of the nodeMappingDictionary keys (the number of keys) followed by the number of bytes to read for the values of thoes keys.    
# def write_outfile():

import pickle    
with open('file.txt', 'wb') as file:
    file.write(pickle.dumps(nodeMappingDict))

    # # include the length of the bytes to read (so to know to throw the remaing bits if there are padded bits added as below)
    # write the bit string representation to a file using int("00000000", 2) to create an integer representation of each bit
    # if there are not eight values in the bit string, pad the string with zeroes to complete and write the remainder out.

# file_path = "output.txt"
# with open(file_path, "wb") as file:
#     binary_data = b"\x00"
#     file.write(binary_data)